//
//  NavigationManager.swift
//  Rotorsync
//
//  Created on 11/15/25.
//

import Foundation
import MapKit
import Combine
import AVFoundation

class NavigationManager: NSObject, ObservableObject {
    // MARK: - Published Properties
    @Published var status: NavigationStatus = .idle
    @Published var availableRoutes: [NavigationRoute] = []
    @Published var selectedRoute: NavigationRoute?
    @Published var currentStepIndex: Int = 0
    @Published var remainingDistance: Double = 0 // meters
    @Published var remainingTime: TimeInterval = 0 // seconds
    @Published var nextStep: NavigationStep?
    @Published var currentStep: NavigationStep?
    @Published var distanceToNextStep: Double = 0
    @Published var voiceGuidanceEnabled: Bool = true
    @Published var waypoints: [CLLocationCoordinate2D] = []
    @Published var remainingRoutePolyline: MKPolyline? // Only the portion ahead of user

    // MARK: - Properties
    private let locationManager: LocationManager
    private var fullRoutePolyline: MKPolyline? // Complete route for reference
    private var settings = NavigationSettings.load()
    private var cancellables = Set<AnyCancellable>()
    private var routeSteps: [NavigationStep] = []
    var destination: CLLocationCoordinate2D? // Made public for recalculation
    private let speechSynthesizer = AVSpeechSynthesizer()
    private var lastAnnouncedDistance: Double?
    private let offRouteThreshold: CLLocationDistance = 150 // meters (increased from 50 for less false positives)
    private var consecutiveOffRouteCount = 0
    private var lastRerouteTime: Date?

    // Voice announcement distances (in meters)
    private let announcementDistances: [Double] = [804.672, 402.336, 161.3344, 30.48] // 2640ft, 1320ft, 529ft, 100ft

    // MARK: - Performance Optimization Properties (BUG-002 & BUG-003 fixes)
    private var lastTrimmedIndex: Int = 0
    private var lastTrimLocation: CLLocation?
    private var lastOffRouteCheckIndex: Int = 0
    private let trimThreshold: CLLocationDistance = 20 // Only trim if moved >20 meters
    private let indexChangeThreshold: Int = 5 // Only create new polyline if index changed >5 points

    // MARK: - Initialization
    init(locationManager: LocationManager) {
        self.locationManager = locationManager
        super.init()
        self.voiceGuidanceEnabled = settings.voiceGuidanceEnabled
        setupLocationTracking()
    }

    // MARK: - Route Calculation
    func calculateRoutes(to destination: CLLocationCoordinate2D) {
        print("üß≠ [NAV MANAGER] calculateRoutes called")
        print("üß≠ [NAV MANAGER] Destination: \(destination.latitude), \(destination.longitude)")
        print("üß≠ [NAV MANAGER] Waypoints: \(waypoints.count)")
        self.destination = destination
        status = .calculatingRoute
        print("üß≠ [NAV MANAGER] Status set to: calculatingRoute")

        // Reload settings to get latest preferences
        settings = NavigationSettings.load()
        print("üß≠ [NAV MANAGER] Settings loaded - avoidHighways: \(settings.avoidHighways)")

        guard let userLocation = locationManager.userLocation else {
            print("‚ùå [NAV MANAGER] No user location available")
            status = .error("Unable to get current location")
            return
        }
        print("üß≠ [NAV MANAGER] User location: \(userLocation.coordinate.latitude), \(userLocation.coordinate.longitude)")

        // If waypoints exist, use chained routing
        if !waypoints.isEmpty {
            print("üß≠ [NAV MANAGER] Using waypoint routing with \(waypoints.count) waypoints")
            calculateRoutesWithWaypoints(from: userLocation.coordinate, to: destination)
            return
        }

        let request = MKDirections.Request()
        request.source = MKMapItem(placemark: MKPlacemark(coordinate: userLocation.coordinate))
        request.destination = MKMapItem(placemark: MKPlacemark(coordinate: destination))
        request.transportType = .automobile
        request.requestsAlternateRoutes = true

        // Apply highway avoidance if enabled
        if settings.avoidHighways {
            request.highwayPreference = .avoid
        }

        let directions = MKDirections(request: request)

        directions.calculate { [weak self] response, error in
            guard let self = self else {
                print("‚ùå [NAV MANAGER] Self was deallocated")
                return
            }

            if let error = error {
                print("‚ùå [NAV MANAGER] Route calculation failed: \(error.localizedDescription)")
                self.status = .error("Failed to calculate route: \(error.localizedDescription)")
                return
            }

            guard let response = response, !response.routes.isEmpty else {
                print("‚ùå [NAV MANAGER] No routes found in response")
                self.status = .error("No routes found")
                return
            }

            print("‚úÖ [NAV MANAGER] Found \(response.routes.count) routes")

            // Convert to NavigationRoute objects
            let navRoutes = response.routes.enumerated().map { index, route in
                let name = index == 0 ? "Fastest Route" : "Alternate Route \(index)"
                print("üß≠ [NAV MANAGER] Route \(index): \(name) - \(route.distance/1609.34) mi, \(route.expectedTravelTime/60) min")
                return NavigationRoute(
                    route: route,
                    name: name,
                    distance: route.distance,
                    expectedTravelTime: route.expectedTravelTime,
                    combinedPolyline: nil,
                    routeSegments: nil
                )
            }

            self.availableRoutes = navRoutes
            self.status = .selectingRoute(navRoutes)
            print("‚úÖ [NAV MANAGER] Status set to: selectingRoute with \(navRoutes.count) routes")
        }
    }

    // MARK: - Waypoint Management
    func addWaypoint(_ coordinate: CLLocationCoordinate2D) {
        print("üìç [WAYPOINT] Adding waypoint at: \(coordinate.latitude), \(coordinate.longitude)")

        // Add waypoint immediately
        waypoints.append(coordinate)
        print("üìç [WAYPOINT] Total waypoints: \(waypoints.count)")

        // Recalculate routes with new waypoint
        if let dest = destination {
            print("üìç [WAYPOINT] Triggering recalculation to: \(dest.latitude), \(dest.longitude)")
            calculateRoutes(to: dest)
        } else {
            print("‚ùå [WAYPOINT] No destination set!")
        }
    }

    func removeWaypoint(at index: Int) {
        guard index < waypoints.count else { return }
        print("üìç [WAYPOINT] Removing waypoint \(index + 1)")
        waypoints.remove(at: index)

        // Recalculate routes without this waypoint
        if let dest = destination {
            calculateRoutes(to: dest)
        }
    }

    func clearWaypoints() {
        print("üìç [WAYPOINT] Clearing all waypoints")
        waypoints.removeAll()
    }

    // MARK: - Multi-Segment Route Calculation
    private func calculateRoutesWithWaypoints(from origin: CLLocationCoordinate2D, to destination: CLLocationCoordinate2D) {
        print("üß≠ [WAYPOINT ROUTING] Calculating route with \(waypoints.count) waypoints")

        // Auto-sort waypoints for efficient routing
        sortWaypointsAlongPath(from: origin, to: destination)
    }

    private func sortWaypointsAlongPath(from origin: CLLocationCoordinate2D, to destination: CLLocationCoordinate2D) {
        guard !waypoints.isEmpty else {
            calculateSegmentedRoute(from: origin, waypoints: [], to: destination)
            return
        }

        print("üîÑ [WAYPOINT SORT] Sorting \(waypoints.count) waypoints for optimal order")

        // Calculate direct route to find natural path
        let directRequest = MKDirections.Request()
        directRequest.source = MKMapItem(placemark: MKPlacemark(coordinate: origin))
        directRequest.destination = MKMapItem(placemark: MKPlacemark(coordinate: destination))
        directRequest.transportType = .automobile
        directRequest.requestsAlternateRoutes = false

        if settings.avoidHighways {
            directRequest.highwayPreference = .avoid
        }

        MKDirections(request: directRequest).calculate { [weak self] response, error in
            guard let self = self, let directRoute = response?.routes.first else {
                print("‚ö†Ô∏è [WAYPOINT SORT] Direct route failed, using waypoint order as-is")
                self?.calculateSegmentedRoute(from: origin, waypoints: self?.waypoints ?? [], to: destination)
                return
            }

            // Find position of each waypoint along the route
            var waypointPositions: [(waypoint: CLLocationCoordinate2D, distanceAlongRoute: Double)] = []

            for waypoint in self.waypoints {
                let (closestPoint, distanceAlong) = self.findPositionAlongRoute(for: waypoint, route: directRoute)
                waypointPositions.append((waypoint: waypoint, distanceAlongRoute: distanceAlong))
                print("üìç [WAYPOINT SORT] Waypoint at \(waypoint.latitude), \(waypoint.longitude) ‚Üí \(distanceAlong/1609.34) mi along route")
            }

            // Sort waypoints by their position along the route (closest to origin first)
            waypointPositions.sort { $0.distanceAlongRoute < $1.distanceAlongRoute }

            let sortedWaypoints = waypointPositions.map { $0.waypoint }

            print("üîÑ [WAYPOINT SORT] Sorted waypoints:")
            for (i, wp) in sortedWaypoints.enumerated() {
                print("   \(i+1). \(wp.latitude), \(wp.longitude)")
            }

            // Update the waypoints array with sorted order
            self.waypoints = sortedWaypoints

            // Calculate route through sorted waypoints
            self.calculateSegmentedRoute(from: origin, waypoints: sortedWaypoints, to: destination)
        }
    }

    private func findPositionAlongRoute(for waypoint: CLLocationCoordinate2D, route: MKRoute) -> (closestPoint: CLLocationCoordinate2D, distanceAlongRoute: Double) {
        let waypointLocation = CLLocation(latitude: waypoint.latitude, longitude: waypoint.longitude)
        let points = route.polyline.points()
        let count = route.polyline.pointCount

        var closestIndex = 0
        var minDistance: CLLocationDistance = .greatestFiniteMagnitude

        // Find closest point on route
        for i in 0..<count {
            let pointCoord = points[i].coordinate
            let pointLocation = CLLocation(latitude: pointCoord.latitude, longitude: pointCoord.longitude)
            let distance = waypointLocation.distance(from: pointLocation)

            if distance < minDistance {
                minDistance = distance
                closestIndex = i
            }
        }

        // Calculate distance along route to this point
        var distanceAlongRoute: Double = 0
        for i in 0..<closestIndex {
            if i + 1 < count {
                let coord1 = points[i].coordinate
                let coord2 = points[i + 1].coordinate
                let loc1 = CLLocation(latitude: coord1.latitude, longitude: coord1.longitude)
                let loc2 = CLLocation(latitude: coord2.latitude, longitude: coord2.longitude)
                distanceAlongRoute += loc1.distance(from: loc2)
            }
        }

        return (points[closestIndex].coordinate, distanceAlongRoute)
    }

    private func calculateOptimalWaypointRoute(from origin: CLLocationCoordinate2D, to destination: CLLocationCoordinate2D) {
        print("üß≠ [WAYPOINT OPT] Calculating direct route first for optimization")

        // Step 1: Calculate direct route to see the natural path
        let directRequest = MKDirections.Request()
        directRequest.source = MKMapItem(placemark: MKPlacemark(coordinate: origin))
        directRequest.destination = MKMapItem(placemark: MKPlacemark(coordinate: destination))
        directRequest.transportType = .automobile
        directRequest.requestsAlternateRoutes = false

        if settings.avoidHighways {
            directRequest.highwayPreference = .avoid
        }

        MKDirections(request: directRequest).calculate { [weak self] response, error in
            guard let self = self, let directRoute = response?.routes.first else {
                print("‚ö†Ô∏è [WAYPOINT OPT] Direct route failed, using raw waypoints")
                self?.calculateSegmentedRoute(from: origin, waypoints: self?.waypoints ?? [], to: destination)
                return
            }

            print("‚úÖ [WAYPOINT OPT] Direct route calculated: \(directRoute.distance/1609.34) mi")

            // Step 2: Find optimal points along direct route near each waypoint
            var optimizedWaypoints: [CLLocationCoordinate2D] = []

            print("üìç [WAYPOINT OPT] Original waypoints: \(self.waypoints.count)")
            for (index, waypoint) in (self.waypoints).enumerated() {
                print("üìç [WAYPOINT OPT] Original waypoint \(index+1): \(waypoint.latitude), \(waypoint.longitude)")
                let optimalPoint = self.findClosestPointOnRoute(to: waypoint, route: directRoute)
                optimizedWaypoints.append(optimalPoint)
                print("üìç [WAYPOINT OPT] Optimized waypoint \(index+1): \(optimalPoint.latitude), \(optimalPoint.longitude)")
            }

            print("üìç [WAYPOINT OPT] Using \(optimizedWaypoints.count) optimized waypoints")
            // Step 3: Calculate segmented route with optimized waypoints
            self.calculateSegmentedRoute(from: origin, waypoints: optimizedWaypoints, to: destination)
        }
    }

    private func findClosestPointOnRoute(to waypoint: CLLocationCoordinate2D, route: MKRoute) -> CLLocationCoordinate2D {
        let waypointLocation = CLLocation(latitude: waypoint.latitude, longitude: waypoint.longitude)
        let points = route.polyline.points()
        let count = route.polyline.pointCount

        var closestPoint = waypoint
        var minDistance: CLLocationDistance = .greatestFiniteMagnitude

        // Sample every 5th point for better accuracy (was every 10th)
        let stride = max(1, count / 200) // Sample ~200 points for better precision

        for i in Swift.stride(from: 0, to: count, by: stride) {
            let pointCoord = points[i].coordinate
            let pointLocation = CLLocation(latitude: pointCoord.latitude, longitude: pointCoord.longitude)
            let distance = waypointLocation.distance(from: pointLocation)

            if distance < minDistance {
                minDistance = distance
                closestPoint = pointCoord
            }
        }

        print("üìç [WAYPOINT OPT] Snapped waypoint from \(waypointLocation.coordinate.latitude), \(waypointLocation.coordinate.longitude)")
        print("üìç [WAYPOINT OPT] To point on route: \(closestPoint.latitude), \(closestPoint.longitude)")
        print("üìç [WAYPOINT OPT] Distance from tap: \(minDistance/1609.34) miles")
        return closestPoint
    }

    private func calculateSegmentedRoute(from origin: CLLocationCoordinate2D, waypoints: [CLLocationCoordinate2D], to destination: CLLocationCoordinate2D) {
        // Build coordinate chain: origin ‚Üí waypoint1 ‚Üí waypoint2 ‚Üí ... ‚Üí destination
        var coordinates = [origin] + waypoints + [destination]
        print("üß≠ [WAYPOINT ROUTING] Total segments: \(coordinates.count - 1)")
        print("üß≠ [WAYPOINT ROUTING] Origin: \(origin.latitude), \(origin.longitude)")
        for (i, wp) in waypoints.enumerated() {
            print("üß≠ [WAYPOINT ROUTING] Waypoint \(i+1): \(wp.latitude), \(wp.longitude)")
        }
        print("üß≠ [WAYPOINT ROUTING] Destination: \(destination.latitude), \(destination.longitude)")

        var allSegmentRoutes: [[MKRoute]] = Array(repeating: [], count: coordinates.count - 1)
        let dispatchGroup = DispatchGroup()
        var hasError = false

        // Calculate each segment
        for i in 0..<(coordinates.count - 1) {
            dispatchGroup.enter()

            let request = MKDirections.Request()
            request.source = MKMapItem(placemark: MKPlacemark(coordinate: coordinates[i]))
            request.destination = MKMapItem(placemark: MKPlacemark(coordinate: coordinates[i + 1]))
            request.transportType = .automobile
            request.requestsAlternateRoutes = true // Request alternates for different routing options

            if settings.avoidHighways {
                request.highwayPreference = .avoid
            }

            let fromCoord = coordinates[i]
            let toCoord = coordinates[i + 1]
            print("üß≠ [WAYPOINT ROUTING] Segment \(i + 1): FROM (\(fromCoord.latitude), \(fromCoord.longitude)) TO (\(toCoord.latitude), \(toCoord.longitude))")

            MKDirections(request: request).calculate { response, error in
                defer { dispatchGroup.leave() }

                if let error = error {
                    print("‚ùå [WAYPOINT ROUTING] Segment \(i + 1) failed: \(error.localizedDescription)")
                    hasError = true
                    return
                }

                if let routes = response?.routes, !routes.isEmpty {
                    print("‚úÖ [WAYPOINT ROUTING] Segment \(i + 1) calculated: \(routes.count) route options")
                    for (idx, route) in routes.enumerated() {
                        print("   Route \(idx + 1): \(route.distance/1609.34) mi")
                    }
                    allSegmentRoutes[i] = routes
                }
            }
        }

        // Wait for all segments to complete
        dispatchGroup.notify(queue: .main) { [weak self] in
            guard let self = self else { return }

            if hasError {
                print("‚ùå [WAYPOINT ROUTING] Failed to calculate all segments")
                self.status = .error("Failed to calculate route through waypoints")
                return
            }

            // Combine segments into complete route
            self.combineRouteSegments(allSegmentRoutes)
        }
    }

    private func combineRouteSegments(_ segmentRoutes: [[MKRoute]]) {
        print("üß≠ [WAYPOINT ROUTING] Combining \(segmentRoutes.count) route segments")

        guard !segmentRoutes.isEmpty, segmentRoutes.allSatisfy({ !$0.isEmpty }) else {
            print("‚ùå [WAYPOINT ROUTING] Missing route segments")
            status = .error("Could not complete route calculation")
            return
        }

        // Create up to 3 route combinations from segment alternates
        var combinedRoutes: [NavigationRoute] = []

        // Combination 1: Fastest route for each segment
        let fastestCombo = segmentRoutes.map { $0.first! }
        if let route1 = createCombinedRoute(from: fastestCombo, name: "Fastest Route") {
            combinedRoutes.append(route1)
        }

        // Combination 2: Use second route option for first segment if available
        if segmentRoutes[0].count > 1 {
            var combo2 = segmentRoutes.map { $0.first! }
            combo2[0] = segmentRoutes[0][1]
            if let route2 = createCombinedRoute(from: combo2, name: "Alternate Route 1") {
                combinedRoutes.append(route2)
            }
        }

        // Combination 3: Use second route for last segment if available and multi-segment
        if segmentRoutes.count > 1, segmentRoutes[segmentRoutes.count - 1].count > 1 {
            var combo3 = segmentRoutes.map { $0.first! }
            combo3[segmentRoutes.count - 1] = segmentRoutes[segmentRoutes.count - 1][1]
            if let route3 = createCombinedRoute(from: combo3, name: "Alternate Route 2") {
                combinedRoutes.append(route3)
            }
        }

        print("‚úÖ [WAYPOINT ROUTING] Created \(combinedRoutes.count) route options")

        availableRoutes = combinedRoutes
        status = .selectingRoute(combinedRoutes)
    }

    private func createCombinedRoute(from segments: [MKRoute], name: String) -> NavigationRoute? {
        guard !segments.isEmpty else { return nil }

        // Combine all polylines
        var allCoordinates: [CLLocationCoordinate2D] = []
        for route in segments {
            let points = route.polyline.points()
            for i in 0..<route.polyline.pointCount {
                allCoordinates.append(points[i].coordinate)
            }
        }

        // Create combined polyline
        let combinedPolyline = MKPolyline(coordinates: allCoordinates, count: allCoordinates.count)

        // Calculate total distance and time
        let totalDistance = segments.reduce(0.0) { $0 + $1.distance }
        let totalTime = segments.reduce(0.0) { $0 + $1.expectedTravelTime }

        print("‚úÖ [WAYPOINT ROUTING] \(name): \(totalDistance/1609.34) mi, \(totalTime/60) min")

        return NavigationRoute(
            route: segments[0],
            name: name,
            distance: totalDistance,
            expectedTravelTime: totalTime,
            combinedPolyline: combinedPolyline,
            routeSegments: segments
        )
    }

    // MARK: - Start Navigation
    func startNavigation(with route: NavigationRoute) {
        print("üß≠ [NAV START] startNavigation called")
        selectedRoute = route

        // BUG-002 & BUG-003 FIX: Reset cache variables for new route
        lastTrimmedIndex = 0
        lastTrimLocation = nil
        lastOffRouteCheckIndex = 0

        // Store full route polyline for trimming as user progresses
        fullRoutePolyline = route.combinedPolyline ?? route.route.polyline
        remainingRoutePolyline = fullRoutePolyline // Start with full route

        // Handle waypoint routes specially - combine all segment steps
        if let segments = route.routeSegments, !segments.isEmpty {
            print("üß≠ [NAV START] Using \(segments.count) route segments for waypoint route")
            prepareStepsFromSegments(segments, totalDistance: route.distance, totalTime: route.expectedTravelTime)
        } else {
            print("üß≠ [NAV START] Using single route with \(route.route.steps.count) steps")
            prepareSteps(from: route.route)
        }

        print("üß≠ [NAV START] Prepared \(routeSteps.count) total steps")
        currentStepIndex = 0
        updateCurrentAndNextSteps()
        status = .navigating
        print("üß≠ [NAV START] Status set to: navigating")
        print("üß≠ [NAV START] Current step: \(currentStep?.instruction ?? "none")")

        // Announce start
        if voiceGuidanceEnabled {
            speak("Navigation started. \(route.distanceString) to destination.")
        }
    }

    // MARK: - Stop Navigation
    func stopNavigation() {
        print("üõë [NAV STOP] stopNavigation called")
        print("üõë [NAV STOP] Previous status: \(status)")
        status = .idle
        selectedRoute = nil
        routeSteps = []
        currentStepIndex = 0
        currentStep = nil
        nextStep = nil
        remainingDistance = 0
        remainingTime = 0
        distanceToNextStep = 0
        lastAnnouncedDistance = nil
        consecutiveOffRouteCount = 0
        fullRoutePolyline = nil
        remainingRoutePolyline = nil
        speechSynthesizer.stopSpeaking(at: .immediate)

        // BUG-002 & BUG-003 FIX: Reset cache variables
        lastTrimmedIndex = 0
        lastTrimLocation = nil
        lastOffRouteCheckIndex = 0

        print("üõë [NAV STOP] Navigation stopped, status now: idle")
    }

    // MARK: - Private Methods
    private func setupLocationTracking() {
        locationManager.$userLocation
            .compactMap { $0 }
            .sink { [weak self] location in
                self?.updateNavigationProgress(with: location)
            }
            .store(in: &cancellables)
    }

    private func prepareSteps(from route: MKRoute) {
        routeSteps = route.steps.map { step in
            NavigationStep(
                instruction: step.instructions,
                distance: step.distance,
                polyline: step.polyline,
                notice: step.notice
            )
        }

        remainingDistance = route.distance
        remainingTime = route.expectedTravelTime
    }

    private func prepareStepsFromSegments(_ segments: [MKRoute], totalDistance: Double, totalTime: TimeInterval) {
        print("üß≠ [NAV START] Combining steps from \(segments.count) segments")

        // Combine all steps from all segments
        var allSteps: [NavigationStep] = []

        for (segmentIndex, segment) in segments.enumerated() {
            print("üß≠ [NAV START] Segment \(segmentIndex + 1) has \(segment.steps.count) steps")

            let segmentSteps = segment.steps.map { step in
                NavigationStep(
                    instruction: step.instructions,
                    distance: step.distance,
                    polyline: step.polyline,
                    notice: step.notice
                )
            }

            allSteps.append(contentsOf: segmentSteps)
        }

        routeSteps = allSteps
        remainingDistance = totalDistance
        remainingTime = totalTime

        print("üß≠ [NAV START] Total combined steps: \(allSteps.count)")
    }

    private func updateCurrentAndNextSteps() {
        guard currentStepIndex < routeSteps.count else {
            currentStep = nil
            nextStep = nil
            return
        }

        currentStep = routeSteps[currentStepIndex]

        if currentStepIndex + 1 < routeSteps.count {
            nextStep = routeSteps[currentStepIndex + 1]
        } else {
            nextStep = nil
        }
    }

    private func updateNavigationProgress(with location: CLLocation) {
        guard status == .navigating || status == .rerouting,
              let route = selectedRoute,
              currentStepIndex < routeSteps.count else {
            print("üîä [NAV PROGRESS] Not updating - status: \(status), stepIndex: \(currentStepIndex)/\(routeSteps.count)")
            return
        }

        let currentLocation = location.coordinate
        let currentStepCoordinate = getStepCoordinate(at: currentStepIndex)

        // Calculate distance to current step
        let stepLocation = CLLocation(latitude: currentStepCoordinate.latitude, longitude: currentStepCoordinate.longitude)
        distanceToNextStep = location.distance(from: stepLocation)

        print("üîä [NAV PROGRESS] Step \(currentStepIndex + 1)/\(routeSteps.count), distance to step: \(distanceToNextStep)m (\(distanceToNextStep * 3.28084)ft)")

        // Update remaining route polyline (trim traveled portion)
        trimRoutePolyline(userLocation: location)

        // Check if we should advance to next step (within 20 meters)
        if distanceToNextStep < 20 {
            advanceToNextStep()
        }

        // Update remaining distance and time
        updateRemainingStats(from: location)

        // Check for backtracking first (immediate reroute)
        if checkBacktracking(location: location) {
            print("üîÑ [BACKTRACK] Immediate reroute triggered")
            handleOffRoute()
            return
        }

        // Check if off route
        if isOffRoute(location: location) {
            consecutiveOffRouteCount += 1
            print("‚ö†Ô∏è [OFF ROUTE] Off route detected - count: \(consecutiveOffRouteCount)/5")
            if consecutiveOffRouteCount >= 5 { // 5 consecutive readings to avoid false positives
                print("üî¥ [OFF ROUTE] Triggering reroute after 5 consecutive readings")
                handleOffRoute()
            }
        } else {
            if consecutiveOffRouteCount > 0 {
                print("‚úÖ [ON ROUTE] Back on route - resetting counter")
            }
            consecutiveOffRouteCount = 0
        }

        // Voice guidance - use published property
        print("üîä [NAV PROGRESS] Voice check - enabled: \(voiceGuidanceEnabled), distance: \(distanceToNextStep)m")
        if voiceGuidanceEnabled {
            announceIfNeeded(distanceToStep: distanceToNextStep)
        } else {
            print("‚ö†Ô∏è [NAV PROGRESS] Voice guidance disabled - skipping announcement")
        }

        // Check if arrived
        if let dest = destination {
            let destLocation = CLLocation(latitude: dest.latitude, longitude: dest.longitude)
            if location.distance(from: destLocation) < 30 { // Within 30 meters
                arriveAtDestination()
            }
        }
    }

    private func getStepCoordinate(at index: Int) -> CLLocationCoordinate2D {
        guard index < routeSteps.count else {
            return destination ?? CLLocationCoordinate2D()
        }

        let step = routeSteps[index]
        let points = step.polyline.points()
        let count = step.polyline.pointCount

        if count > 0 {
            return points[count - 1].coordinate
        }

        return destination ?? CLLocationCoordinate2D()
    }

    private func advanceToNextStep() {
        currentStepIndex += 1
        updateCurrentAndNextSteps()
        lastAnnouncedDistance = nil // Reset for next step

        if let instruction = currentStep?.instruction, !instruction.isEmpty {
            if voiceGuidanceEnabled {
                speak(instruction)
            }
        }
    }

    private func updateRemainingStats(from location: CLLocation) {
        guard let route = selectedRoute else { return }

        // Calculate remaining distance (simple approximation)
        var distance: Double = 0
        for i in currentStepIndex..<routeSteps.count {
            distance += routeSteps[i].distance
        }
        distance += distanceToNextStep

        remainingDistance = distance

        // Estimate remaining time based on current speed
        if let speed = locationManager.userLocation?.speed, speed > 0 {
            remainingTime = distance / speed
        } else {
            // Fallback to original estimate
            let progress = 1.0 - (distance / route.distance)
            remainingTime = route.expectedTravelTime * (1.0 - progress)
        }
    }

    private func isOffRoute(location: CLLocation) -> Bool {
        guard currentStepIndex < routeSteps.count else { return false }

        let step = routeSteps[currentStepIndex]
        let polyline = step.polyline

        // Check distance to polyline
        let distance = distanceToPolyline(from: location.coordinate, polyline: polyline)
        let isOff = distance > offRouteThreshold

        if isOff {
            print("‚ö†Ô∏è [OFF ROUTE CHECK] Distance from route: \(distance)m (threshold: \(offRouteThreshold)m)")
        }

        return isOff
    }

    private func distanceToPolyline(from coordinate: CLLocationCoordinate2D, polyline: MKPolyline) -> CLLocationDistance {
        let points = polyline.points()
        let count = polyline.pointCount

        var minDistance = CLLocationDistance.greatestFiniteMagnitude
        let userLocation = CLLocation(latitude: coordinate.latitude, longitude: coordinate.longitude)

        // BUG-003 FIX: Start search from cached position ¬±100 points for better performance
        let searchStart = max(0, lastOffRouteCheckIndex - 100)
        let searchEnd = min(count - 1, lastOffRouteCheckIndex + 100)

        // First, search in the cached region
        var closestIndex = lastOffRouteCheckIndex

        for i in searchStart...searchEnd {
            let pointCoord = points[i].coordinate
            let pointLocation = CLLocation(latitude: pointCoord.latitude, longitude: pointCoord.longitude)
            let distance = userLocation.distance(from: pointLocation)

            if distance < minDistance {
                minDistance = distance
                closestIndex = i
            }
        }

        // BUG-003 FIX: If distance is still large, do a sparse full search
        if minDistance > offRouteThreshold {
            // Sample every 10th point for full route check
            let stride = max(1, count / 100)
            for i in Swift.stride(from: 0, to: count, by: stride) {
                let pointCoord = points[i].coordinate
                let pointLocation = CLLocation(latitude: pointCoord.latitude, longitude: pointCoord.longitude)
                let distance = userLocation.distance(from: pointLocation)

                if distance < minDistance {
                    minDistance = distance
                    closestIndex = i
                }
            }

            // Fine-tune around the best sparse result
            let refinedStart = max(0, closestIndex - stride)
            let refinedEnd = min(count - 1, closestIndex + stride)
            for i in refinedStart...refinedEnd {
                let pointCoord = points[i].coordinate
                let pointLocation = CLLocation(latitude: pointCoord.latitude, longitude: pointCoord.longitude)
                let distance = userLocation.distance(from: pointLocation)

                if distance < minDistance {
                    minDistance = distance
                    closestIndex = i
                }
            }
        }

        // Update cache for next iteration
        lastOffRouteCheckIndex = closestIndex

        return minDistance
    }

    private func handleOffRoute() {
        guard status == .navigating, let dest = destination else { return }

        // Cooldown: Don't reroute more than once every 30 seconds
        if let lastReroute = lastRerouteTime {
            let timeSinceLastReroute = Date().timeIntervalSince(lastReroute)
            if timeSinceLastReroute < 30 {
                print("‚ö†Ô∏è [OFF ROUTE] Too soon to reroute (last: \(timeSinceLastReroute)s ago)")
                consecutiveOffRouteCount = 0 // Reset to prevent spam
                return
            }
        }

        print("üîÑ [OFF ROUTE] Rerouting - \(consecutiveOffRouteCount) consecutive off-route readings")
        lastRerouteTime = Date()
        status = .rerouting

        if voiceGuidanceEnabled {
            speak("Recalculating route")
        }

        // Recalculate route
        calculateRoutes(to: dest)

        // Auto-select first route when recalculated
        DispatchQueue.main.asyncAfter(deadline: .now() + 1.0) { [weak self] in
            guard let self = self else { return }
            if case .selectingRoute(let routes) = self.status, let firstRoute = routes.first {
                self.startNavigation(with: firstRoute)
            }
        }
    }

    private func trimRoutePolyline(userLocation: CLLocation) {
        guard let fullPolyline = fullRoutePolyline else { return }

        // BUG-002 FIX: Only trim if user has moved >20 meters since last trim
        if let lastLoc = lastTrimLocation, userLocation.distance(from: lastLoc) < trimThreshold {
            return // Skip trimming, user hasn't moved enough
        }

        let points = fullPolyline.points()
        let count = fullPolyline.pointCount

        // BUG-002 FIX: Use binary search instead of linear iteration
        var closestIndex = binarySearchClosestPoint(
            points: points,
            count: count,
            location: userLocation,
            startIndex: max(0, lastTrimmedIndex - 50), // Search from cached position ¬±50 points
            endIndex: min(count - 1, lastTrimmedIndex + 50)
        )

        // Fallback to full search if binary search result is too far
        let closestPoint = points[closestIndex].coordinate
        let closestPointLoc = CLLocation(latitude: closestPoint.latitude, longitude: closestPoint.longitude)
        if userLocation.distance(from: closestPointLoc) > 100 {
            // User might have jumped far, do full linear search
            closestIndex = linearSearchClosestPoint(points: points, count: count, location: userLocation)
        }

        // BUG-002 FIX: Only create new polyline if index changed significantly (>5 points)
        if abs(closestIndex - lastTrimmedIndex) < indexChangeThreshold && lastTrimLocation != nil {
            return // Index hasn't changed enough, skip polyline creation
        }

        // Create polyline from closest point to end (only remaining portion)
        if closestIndex < count - 1 {
            var remainingCoordinates: [CLLocationCoordinate2D] = []

            for i in closestIndex..<count {
                remainingCoordinates.append(points[i].coordinate)
            }

            // Create new polyline with only remaining portion
            let newPolyline = MKPolyline(coordinates: remainingCoordinates, count: remainingCoordinates.count)
            remainingRoutePolyline = newPolyline

            // Update cache
            lastTrimmedIndex = closestIndex
            lastTrimLocation = userLocation
        }
    }

    // BUG-002 FIX: Binary search helper for finding closest point
    private func binarySearchClosestPoint(points: UnsafeMutablePointer<MKMapPoint>, count: Int, location: CLLocation, startIndex: Int, endIndex: Int) -> Int {
        guard startIndex < endIndex else { return startIndex }

        var left = startIndex
        var right = endIndex
        var closestIndex = left
        var minDistance = CLLocationDistance.greatestFiniteMagnitude

        // Check a few samples in the range using binary search approach
        let sampleIndices = [left, (left + right) / 2, right]

        for index in sampleIndices where index < count {
            let pointCoord = points[index].coordinate
            let pointLocation = CLLocation(latitude: pointCoord.latitude, longitude: pointCoord.longitude)
            let distance = location.distance(from: pointLocation)

            if distance < minDistance {
                minDistance = distance
                closestIndex = index
            }
        }

        // Fine-tune search around the closest sample
        let searchRadius = 20
        let refinedStart = max(0, closestIndex - searchRadius)
        let refinedEnd = min(count - 1, closestIndex + searchRadius)

        for i in refinedStart...refinedEnd {
            let pointCoord = points[i].coordinate
            let pointLocation = CLLocation(latitude: pointCoord.latitude, longitude: pointCoord.longitude)
            let distance = location.distance(from: pointLocation)

            if distance < minDistance {
                minDistance = distance
                closestIndex = i
            }
        }

        return closestIndex
    }

    // BUG-002 FIX: Linear search fallback
    private func linearSearchClosestPoint(points: UnsafeMutablePointer<MKMapPoint>, count: Int, location: CLLocation) -> Int {
        var closestIndex = 0
        var minDistance = CLLocationDistance.greatestFiniteMagnitude

        for i in 0..<count {
            let pointCoord = points[i].coordinate
            let pointLocation = CLLocation(latitude: pointCoord.latitude, longitude: pointCoord.longitude)
            let distance = location.distance(from: pointLocation)

            if distance < minDistance {
                minDistance = distance
                closestIndex = i
            }
        }

        return closestIndex
    }

    private func arriveAtDestination() {
        status = .arrived

        if voiceGuidanceEnabled {
            speak("You have arrived at your destination")
        }

        // Auto-stop navigation after 3 seconds
        DispatchQueue.main.asyncAfter(deadline: .now() + 3.0) { [weak self] in
            self?.stopNavigation()
        }
    }

    private func announceIfNeeded(distanceToStep: Double) {
        guard let step = currentStep, !step.instruction.isEmpty else {
            print("üîä [VOICE] No current step or empty instruction")
            return
        }

        print("üîä [VOICE] Checking announcements - distance: \(distanceToStep)m (\(distanceToStep * 3.28084)ft)")
        print("üîä [VOICE] Current step: \(step.instruction)")
        print("üîä [VOICE] Last announced distance: \(lastAnnouncedDistance ?? -1)")

        // Find the appropriate announcement distance (sorted from largest to smallest)
        for threshold in announcementDistances.sorted(by: >) {
            // Check if we just crossed this threshold (within 20% tolerance)
            let inRange = distanceToStep <= threshold && distanceToStep > (threshold * 0.8)
            print("üîä [VOICE] Threshold \(threshold)m (\(threshold * 3.28084)ft): inRange=\(inRange)")

            if inRange {
                // Check if we haven't announced at this distance yet
                if let lastAnnounced = lastAnnouncedDistance {
                    // Only announce if this is a closer threshold than we last announced
                    if threshold < lastAnnounced {
                        let announcement = "In \(formatDistanceForVoice(distanceToStep)), \(step.instruction)"
                        print("üîä [VOICE] Announcing: \(announcement)")
                        speak(announcement)
                        lastAnnouncedDistance = threshold
                        break
                    }
                } else {
                    // First announcement for this step
                    let announcement = "In \(formatDistanceForVoice(distanceToStep)), \(step.instruction)"
                    print("üîä [VOICE] First announcement: \(announcement)")
                    speak(announcement)
                    lastAnnouncedDistance = threshold
                    break
                }
            }
        }
    }

    private func formatDistanceForVoice(_ meters: Double) -> String {
        let feet = meters * 3.28084

        if feet < 100 {
            return "50 feet"
        } else if feet < 1000 {
            let roundedFeet = Int(round(feet / 50) * 50) // Round to nearest 50ft
            return "\(roundedFeet) feet"
        } else {
            let miles = meters / 1609.34
            if miles < 0.2 {
                return "a quarter mile"
            } else if miles < 0.4 {
                return "a third of a mile"
            } else if miles < 0.6 {
                return "half a mile"
            } else {
                return String(format: "%.1f miles", miles)
            }
        }
    }

    private func speak(_ text: String) {
        print("üîä [VOICE] Speaking: '\(text)'")
        print("üîä [VOICE] Voice enabled: \(voiceGuidanceEnabled)")
        print("üîä [VOICE] Synthesizer isSpeaking: \(speechSynthesizer.isSpeaking)")

        // Configure audio session for voice guidance
        do {
            let audioSession = AVAudioSession.sharedInstance()
            try audioSession.setCategory(.playback, mode: .spokenAudio, options: [.duckOthers, .interruptSpokenAudioAndMixWithOthers])
            try audioSession.setActive(true, options: .notifyOthersOnDeactivation)
            print("‚úÖ [VOICE] Audio session configured")
        } catch {
            print("‚ùå [VOICE] Audio session error: \(error.localizedDescription)")
        }

        // Stop any current speech
        if speechSynthesizer.isSpeaking {
            speechSynthesizer.stopSpeaking(at: .immediate)
        }

        let utterance = AVSpeechUtterance(string: text)
        utterance.voice = AVSpeechSynthesisVoice(language: "en-US")
        utterance.rate = 0.52 // Slightly faster than 0.5 for better flow
        utterance.volume = 1.0
        utterance.preUtteranceDelay = 0.1 // Small delay before speaking
        utterance.postUtteranceDelay = 0.1

        print("üîä [VOICE] Utterance created - text length: \(text.count), rate: \(utterance.rate)")
        speechSynthesizer.speak(utterance)
        print("üîä [VOICE] speak() called on synthesizer")

        // Verify speech started
        DispatchQueue.main.asyncAfter(deadline: .now() + 0.2) {
            print("üîä [VOICE] Synthesizer isSpeaking after 0.2s: \(self.speechSynthesizer.isSpeaking)")
        }
    }

    // MARK: - Settings
    func updateSettings(_ newSettings: NavigationSettings) {
        settings = newSettings
        settings.save()
    }

    func toggleVoiceGuidance() {
        voiceGuidanceEnabled.toggle()
        settings.voiceGuidanceEnabled = voiceGuidanceEnabled
        settings.save()
    }
}
