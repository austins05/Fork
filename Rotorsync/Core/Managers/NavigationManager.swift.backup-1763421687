//
//  NavigationManager.swift
//  Rotorsync
//
//  Created on 11/15/25.
//

import Foundation
import MapKit
import Combine
import AVFoundation

class NavigationManager: NSObject, ObservableObject {
    // MARK: - Published Properties
    @Published var status: NavigationStatus = .idle
    @Published var availableRoutes: [NavigationRoute] = []
    @Published var selectedRoute: NavigationRoute?
    @Published var currentStepIndex: Int = 0
    @Published var remainingDistance: Double = 0 // meters
    @Published var remainingTime: TimeInterval = 0 // seconds
    @Published var nextStep: NavigationStep?
    @Published var currentStep: NavigationStep?
    @Published var distanceToNextStep: Double = 0
    @Published var voiceGuidanceEnabled: Bool = true
    @Published var waypoints: [CLLocationCoordinate2D] = []
    @Published var remainingRoutePolyline: MKPolyline? // Only the portion ahead of user

    // MARK: - Properties
    private let locationManager: LocationManager
    private var fullRoutePolyline: MKPolyline? // Complete route for reference
    private var settings = NavigationSettings.load()
    private var cancellables = Set<AnyCancellable>()
    private var routeSteps: [NavigationStep] = []
    var destination: CLLocationCoordinate2D? // Made public for recalculation
    private let speechSynthesizer = AVSpeechSynthesizer()
    private var lastAnnouncedDistance: Double?
    private let offRouteThreshold: CLLocationDistance = 150 // meters (increased from 50 for less false positives)
    private var consecutiveOffRouteCount = 0
    private var lastRerouteTime: Date?

    // Voice announcement distances (in meters)
    private let announcementDistances: [Double] = [804.672, 402.336, 161.3344, 30.48] // 2640ft, 1320ft, 529ft, 100ft

    // MARK: - Validation Constants
    private let minDestinationDistance: CLLocationDistance = 100 // meters (328 feet)
    private let routeCalculationTimeout: TimeInterval = 30.0 // seconds

    // MARK: - Initialization
    init(locationManager: LocationManager) {
        self.locationManager = locationManager
        super.init()
        self.voiceGuidanceEnabled = settings.voiceGuidanceEnabled
        setupLocationTracking()
    }

    // MARK: - Route Calculation
    func calculateRoutes(to destination: CLLocationCoordinate2D) {
        print("üß≠ [NAV MANAGER] calculateRoutes called")
        print("üß≠ [NAV MANAGER] Destination: \(destination.latitude), \(destination.longitude)")
        print("üß≠ [NAV MANAGER] Waypoints: \(waypoints.count)")

        self.destination = destination

        // Reload settings to get latest preferences
        settings = NavigationSettings.load()
        print("üß≠ [NAV MANAGER] Settings loaded - avoidHighways: \(settings.avoidHighways)")

        guard let userLocation = locationManager.userLocation else {
            print("‚ùå [NAV MANAGER] No user location available")
            status = .error("Unable to get current location")
            return
        }
        print("üß≠ [NAV MANAGER] User location: \(userLocation.coordinate.latitude), \(userLocation.coordinate.longitude)")

        // FIX #2: Destination Proximity Check
        let distanceToDestination = userLocation.distance(from: CLLocation(latitude: destination.latitude, longitude: destination.longitude))

        if distanceToDestination < minDestinationDistance {
            let distanceText = String(format: "%.0f meters (%.0f feet)", distanceToDestination, distanceToDestination * 3.28084)
            status = .error("Destination is too close (\(distanceText)) - minimum distance is 100 meters")
            print("üìç [VALIDATION] Destination too close: \(distanceText)")
            return
        }

        print("‚úÖ [VALIDATION] Destination distance check passed: \(String(format: "%.0f meters", distanceToDestination))")

        status = .calculatingRoute
        print("üß≠ [NAV MANAGER] Status set to: calculatingRoute")

        // If waypoints exist, use chained routing
        if !waypoints.isEmpty {
            print("üß≠ [NAV MANAGER] Using waypoint routing with \(waypoints.count) waypoints")
            calculateRoutesWithWaypoints(from: userLocation.coordinate, to: destination)
            return
        }

        let request = MKDirections.Request()
        request.source = MKMapItem(placemark: MKPlacemark(coordinate: userLocation.coordinate))
        request.destination = MKMapItem(placemark: MKPlacemark(coordinate: destination))
        request.transportType = .automobile
        request.requestsAlternateRoutes = true

        // Apply highway avoidance if enabled
        if settings.avoidHighways {
            request.highwayPreference = .avoid
        }

        let directions = MKDirections(request: request)

        // FIX #1: Route Calculation Timeout
        var timeoutWorkItem: DispatchWorkItem?
        timeoutWorkItem = DispatchWorkItem { [weak self] in
            directions.cancel()
            print("‚è±Ô∏è [TIMEOUT] Route calculation timed out after \(self?.routeCalculationTimeout ?? 30.0) seconds")
            self?.status = .error("Route calculation timed out after 30 seconds. Please try again.")
        }
        DispatchQueue.main.asyncAfter(deadline: .now() + routeCalculationTimeout, execute: timeoutWorkItem!)

        directions.calculate { [weak self] response, error in
            guard let self = self else {
                print("‚ùå [NAV MANAGER] Self was deallocated")
                return
            }

            // Cancel timeout on response
            timeoutWorkItem?.cancel()
            print("‚úÖ [TIMEOUT] Timeout cancelled - received response")

            if let error = error {
                print("‚ùå [NAV MANAGER] Route calculation failed: \(error.localizedDescription)")
                self.status = .error("Failed to calculate route: \(error.localizedDescription)")
                return
            }

            guard let response = response, !response.routes.isEmpty else {
                print("‚ùå [NAV MANAGER] No routes found in response")
                self.status = .error("No routes found")
                return
            }

            print("‚úÖ [NAV MANAGER] Found \(response.routes.count) routes")

            // Convert to NavigationRoute objects
            let navRoutes = response.routes.enumerated().map { index, route in
                let name = index == 0 ? "Fastest Route" : "Alternate Route \(index)"
                print("üß≠ [NAV MANAGER] Route \(index): \(name) - \(route.distance/1609.34) mi, \(route.expectedTravelTime/60) min")

                // FIX #3: Highway Avoidance Verification
                if self.settings.avoidHighways {
                    let hasHighway = self.checkForHighways(in: route)
                    if hasHighway {
                        print("‚ö†Ô∏è [HIGHWAY CHECK] Route '\(name)' contains highways despite avoidance preference")
                    } else {
                        print("‚úÖ [HIGHWAY CHECK] Route '\(name)' successfully avoids highways")
                    }
                }

                return NavigationRoute(
                    route: route,
                    name: name,
                    distance: route.distance,
                    expectedTravelTime: route.expectedTravelTime,
                    combinedPolyline: nil,
                    routeSegments: nil
                )
            }

            self.availableRoutes = navRoutes
            self.status = .selectingRoute(navRoutes)
            print("‚úÖ [NAV MANAGER] Status set to: selectingRoute with \(navRoutes.count) routes")
        }
    }

    // FIX #3: Highway Detection Method
    private func checkForHighways(in route: MKRoute) -> Bool {
        let highwayKeywords = ["highway", "interstate", "freeway", "motorway", "expressway", "turnpike"]

        for step in route.steps {
            let instruction = step.instructions.lowercased()
            for keyword in highwayKeywords {
                if instruction.contains(keyword) {
                    print("üõ£Ô∏è [HIGHWAY CHECK] Found '\(keyword)' in: \(step.instructions)")
                    return true
                }
            }
        }

        return false
    }

    // MARK: - Waypoint Management
    func addWaypoint(_ coordinate: CLLocationCoordinate2D) {
        print("üìç [WAYPOINT] Adding waypoint at: \(coordinate.latitude), \(coordinate.longitude)")

        // FIX #4: Waypoint Proximity Validation
        if let userLocation = locationManager.userLocation {
            let distance = userLocation.distance(from: CLLocation(latitude: coordinate.latitude, longitude: coordinate.longitude))

            if distance < minDestinationDistance {
                let distanceText = String(format: "%.0f meters (%.0f feet)", distance, distance * 3.28084)
                print("‚ö†Ô∏è [WAYPOINT VALIDATION] Waypoint too close to current location: \(distanceText)")
                print("‚ö†Ô∏è [WAYPOINT VALIDATION] Minimum distance required: 100 meters (328 feet)")

                // Update status to show error to user
                status = .error("Waypoint is too close (\(distanceText)) - minimum distance is 100 meters")
                return
            }

            print("‚úÖ [WAYPOINT VALIDATION] Waypoint distance check passed: \(String(format: "%.0f meters", distance))")
        }

        // Check proximity to existing waypoints
        for (index, existingWaypoint) in waypoints.enumerated() {
            let existingLocation = CLLocation(latitude: existingWaypoint.latitude, longitude: existingWaypoint.longitude)
            let newLocation = CLLocation(latitude: coordinate.latitude, longitude: coordinate.longitude)
            let distance = existingLocation.distance(from: newLocation)

            if distance < 50 { // 50 meters minimum between waypoints
                print("‚ö†Ô∏è [WAYPOINT VALIDATION] Waypoint too close to existing waypoint \(index + 1): \(String(format: "%.0f meters", distance))")
                status = .error("Waypoint is too close to existing waypoint #\(index + 1)")
                return
            }
        }

        // Add waypoint immediately
        waypoints.append(coordinate)
        print("üìç [WAYPOINT] Total waypoints: \(waypoints.count)")

        // Recalculate routes with new waypoint
        if let dest = destination {
            print("üìç [WAYPOINT] Triggering recalculation to: \(dest.latitude), \(dest.longitude)")
            calculateRoutes(to: dest)
        } else {
            print("‚ùå [WAYPOINT] No destination set!")
        }
    }

    func removeWaypoint(at index: Int) {
        guard index < waypoints.count else { return }
        print("üìç [WAYPOINT] Removing waypoint \(index + 1)")
        waypoints.remove(at: index)

        // Recalculate routes without this waypoint
        if let dest = destination {
            calculateRoutes(to: dest)
        }
    }

    func clearWaypoints() {
        print("üìç [WAYPOINT] Clearing all waypoints")
        waypoints.removeAll()
    }

    // MARK: - Multi-Segment Route Calculation
    private func calculateRoutesWithWaypoints(from origin: CLLocationCoordinate2D, to destination: CLLocationCoordinate2D) {
        print("üß≠ [WAYPOINT ROUTING] Calculating route with \(waypoints.count) waypoints")

        // Auto-sort waypoints for efficient routing
        sortWaypointsAlongPath(from: origin, to: destination)
    }

    private func sortWaypointsAlongPath(from origin: CLLocationCoordinate2D, to destination: CLLocationCoordinate2D) {
        guard !waypoints.isEmpty else {
            calculateSegmentedRoute(from: origin, waypoints: [], to: destination)
            return
        }

        print("üîÑ [WAYPOINT SORT] Sorting \(waypoints.count) waypoints for optimal order")

        // Calculate direct route to find natural path
        let directRequest = MKDirections.Request()
        directRequest.source = MKMapItem(placemark: MKPlacemark(coordinate: origin))
        directRequest.destination = MKMapItem(placemark: MKPlacemark(coordinate: destination))
        directRequest.transportType = .automobile
        directRequest.requestsAlternateRoutes = false

        if settings.avoidHighways {
            directRequest.highwayPreference = .avoid
        }

        // Add timeout for direct route calculation
        let directDirections = MKDirections(request: directRequest)
        var directTimeoutWorkItem: DispatchWorkItem?
        directTimeoutWorkItem = DispatchWorkItem { [weak self] in
            directDirections.cancel()
            print("‚è±Ô∏è [TIMEOUT] Waypoint sorting timed out")
            // Fall back to using waypoints in original order
            self?.calculateSegmentedRoute(from: origin, waypoints: self?.waypoints ?? [], to: destination)
        }
        DispatchQueue.main.asyncAfter(deadline: .now() + routeCalculationTimeout, execute: directTimeoutWorkItem!)

        directDirections.calculate { [weak self] response, error in
            guard let self = self else { return }

            directTimeoutWorkItem?.cancel()

            guard let directRoute = response?.routes.first else {
                print("‚ö†Ô∏è [WAYPOINT SORT] Direct route failed, using waypoint order as-is")
                self.calculateSegmentedRoute(from: origin, waypoints: self.waypoints, to: destination)
                return
            }

            // Find position of each waypoint along the route
            var waypointPositions: [(waypoint: CLLocationCoordinate2D, distanceAlongRoute: Double)] = []

            for waypoint in self.waypoints {
                let (closestPoint, distanceAlong) = self.findPositionAlongRoute(for: waypoint, route: directRoute)
                waypointPositions.append((waypoint: waypoint, distanceAlongRoute: distanceAlong))
                print("üìç [WAYPOINT SORT] Waypoint at \(waypoint.latitude), \(waypoint.longitude) ‚Üí \(distanceAlong/1609.34) mi along route")
            }

            // Sort waypoints by their position along the route (closest to origin first)
            waypointPositions.sort { $0.distanceAlongRoute < $1.distanceAlongRoute }

            let sortedWaypoints = waypointPositions.map { $0.waypoint }

            print("üîÑ [WAYPOINT SORT] Sorted waypoints:")
            for (i, wp) in sortedWaypoints.enumerated() {
                print("   \(i+1). \(wp.latitude), \(wp.longitude)")
            }

            // Update the waypoints array with sorted order
            self.waypoints = sortedWaypoints

            // Calculate route through sorted waypoints
            self.calculateSegmentedRoute(from: origin, waypoints: sortedWaypoints, to: destination)
        }
    }

    private func findPositionAlongRoute(for waypoint: CLLocationCoordinate2D, route: MKRoute) -> (closestPoint: CLLocationCoordinate2D, distanceAlongRoute: Double) {
        let waypointLocation = CLLocation(latitude: waypoint.latitude, longitude: waypoint.longitude)
        let points = route.polyline.points()
        let count = route.polyline.pointCount

        var closestIndex = 0
        var minDistance: CLLocationDistance = .greatestFiniteMagnitude

        // Find closest point on route
        for i in 0..<count {
            let pointCoord = points[i].coordinate
            let pointLocation = CLLocation(latitude: pointCoord.latitude, longitude: pointCoord.longitude)
            let distance = waypointLocation.distance(from: pointLocation)

            if distance < minDistance {
                minDistance = distance
                closestIndex = i
            }
        }

        // Calculate distance along route to this point
        var distanceAlongRoute: Double = 0
        for i in 0..<closestIndex {
            if i + 1 < count {
                let coord1 = points[i].coordinate
                let coord2 = points[i + 1].coordinate
                let loc1 = CLLocation(latitude: coord1.latitude, longitude: coord1.longitude)
                let loc2 = CLLocation(latitude: coord2.latitude, longitude: coord2.longitude)
                distanceAlongRoute += loc1.distance(from: loc2)
            }
        }

        return (points[closestIndex].coordinate, distanceAlongRoute)
    }

    private func calculateOptimalWaypointRoute(from origin: CLLocationCoordinate2D, to destination: CLLocationCoordinate2D) {
        print("üß≠ [WAYPOINT OPT] Calculating direct route first for optimization")

        // Step 1: Calculate direct route to see the natural path
        let directRequest = MKDirections.Request()
        directRequest.source = MKMapItem(placemark: MKPlacemark(coordinate: origin))
        directRequest.destination = MKMapItem(placemark: MKPlacemark(coordinate: destination))
        directRequest.transportType = .automobile
        directRequest.requestsAlternateRoutes = false

        if settings.avoidHighways {
            directRequest.highwayPreference = .avoid
        }

        MKDirections(request: directRequest).calculate { [weak self] response, error in
            guard let self = self, let directRoute = response?.routes.first else {
                print("‚ö†Ô∏è [WAYPOINT OPT] Direct route failed, using raw waypoints")
                self?.calculateSegmentedRoute(from: origin, waypoints: self?.waypoints ?? [], to: destination)
                return
            }

            print("‚úÖ [WAYPOINT OPT] Direct route calculated: \(directRoute.distance/1609.34) mi")

            // Step 2: Find optimal points along direct route near each waypoint
            var optimizedWaypoints: [CLLocationCoordinate2D] = []

            print("üìç [WAYPOINT OPT] Original waypoints: \(self.waypoints.count)")
            for (index, waypoint) in (self.waypoints).enumerated() {
                print("üìç [WAYPOINT OPT] Original waypoint \(index+1): \(waypoint.latitude), \(waypoint.longitude)")
                let optimalPoint = self.findClosestPointOnRoute(to: waypoint, route: directRoute)
                optimizedWaypoints.append(optimalPoint)
                print("üìç [WAYPOINT OPT] Optimized waypoint \(index+1): \(optimalPoint.latitude), \(optimalPoint.longitude)")
            }

            print("üìç [WAYPOINT OPT] Using \(optimizedWaypoints.count) optimized waypoints")
            // Step 3: Calculate segmented route with optimized waypoints
            self.calculateSegmentedRoute(from: origin, waypoints: optimizedWaypoints, to: destination)
        }
    }

    private func findClosestPointOnRoute(to waypoint: CLLocationCoordinate2D, route: MKRoute) -> CLLocationCoordinate2D {
        let waypointLocation = CLLocation(latitude: waypoint.latitude, longitude: waypoint.longitude)
        let points = route.polyline.points()
        let count = route.polyline.pointCount

        var closestPoint = waypoint
        var minDistance: CLLocationDistance = .greatestFiniteMagnitude

        // Sample every 5th point for better accuracy (was every 10th)
        let stride = max(1, count / 200) // Sample ~200 points for better precision

        for i in Swift.stride(from: 0, to: count, by: stride) {
            let pointCoord = points[i].coordinate
            let pointLocation = CLLocation(latitude: pointCoord.latitude, longitude: pointCoord.longitude)
            let distance = waypointLocation.distance(from: pointLocation)

            if distance < minDistance {
                minDistance = distance
                closestPoint = pointCoord
            }
        }

        print("üìç [WAYPOINT OPT] Snapped waypoint from \(waypointLocation.coordinate.latitude), \(waypointLocation.coordinate.longitude)")
        print("üìç [WAYPOINT OPT] To point on route: \(closestPoint.latitude), \(closestPoint.longitude)")
        print("üìç [WAYPOINT OPT] Distance from tap: \(minDistance/1609.34) miles")
        return closestPoint
    }

    private func calculateSegmentedRoute(from origin: CLLocationCoordinate2D, waypoints: [CLLocationCoordinate2D], to destination: CLLocationCoordinate2D) {
        // Build coordinate chain: origin ‚Üí waypoint1 ‚Üí waypoint2 ‚Üí ... ‚Üí destination
        var coordinates = [origin] + waypoints + [destination]
        print("üß≠ [WAYPOINT ROUTING] Total segments: \(coordinates.count - 1)")
        print("üß≠ [WAYPOINT ROUTING] Origin: \(origin.latitude), \(origin.longitude)")
        for (i, wp) in waypoints.enumerated() {
            print("üß≠ [WAYPOINT ROUTING] Waypoint \(i+1): \(wp.latitude), \(wp.longitude)")
        }
        print("üß≠ [WAYPOINT ROUTING] Destination: \(destination.latitude), \(destination.longitude)")

        var allSegmentRoutes: [[MKRoute]] = Array(repeating: [], count: coordinates.count - 1)
        let dispatchGroup = DispatchGroup()
        var hasError = false
        var hasTimeout = false

        // Calculate each segment with timeout
        for i in 0..<(coordinates.count - 1) {
            dispatchGroup.enter()

            let request = MKDirections.Request()
            request.source = MKMapItem(placemark: MKPlacemark(coordinate: coordinates[i]))
            request.destination = MKMapItem(placemark: MKPlacemark(coordinate: coordinates[i + 1]))
            request.transportType = .automobile
            request.requestsAlternateRoutes = true

            if settings.avoidHighways {
                request.highwayPreference = .avoid
            }

            let fromCoord = coordinates[i]
            let toCoord = coordinates[i + 1]
            print("üß≠ [WAYPOINT ROUTING] Segment \(i + 1): FROM (\(fromCoord.latitude), \(fromCoord.longitude)) TO (\(toCoord.latitude), \(toCoord.longitude))")

            let segmentDirections = MKDirections(request: request)

            // Add timeout for each segment
            var segmentTimeoutWorkItem: DispatchWorkItem?
            segmentTimeoutWorkItem = DispatchWorkItem {
                segmentDirections.cancel()
                print("‚è±Ô∏è [TIMEOUT] Segment \(i + 1) timed out after 30 seconds")
                hasTimeout = true
                dispatchGroup.leave()
            }
            DispatchQueue.main.asyncAfter(deadline: .now() + routeCalculationTimeout, execute: segmentTimeoutWorkItem!)

            segmentDirections.calculate { response, error in
                segmentTimeoutWorkItem?.cancel()

                defer {
                    if !hasTimeout {
                        dispatchGroup.leave()
                    }
                }

                if let error = error {
                    print("‚ùå [WAYPOINT ROUTING] Segment \(i + 1) failed: \(error.localizedDescription)")
                    hasError = true
                    return
                }

                if let routes = response?.routes, !routes.isEmpty {
                    print("‚úÖ [WAYPOINT ROUTING] Segment \(i + 1) calculated: \(routes.count) route options")
                    for (idx, route) in routes.enumerated() {
                        print("   Route \(idx + 1): \(route.distance/1609.34) mi")
                    }
                    allSegmentRoutes[i] = routes
                }
            }
        }

        // Wait for all segments to complete
        dispatchGroup.notify(queue: .main) { [weak self] in
            guard let self = self else { return }

            if hasTimeout {
                print("‚ùå [WAYPOINT ROUTING] Route calculation timed out")
                self.status = .error("Route calculation timed out. Please try again.")
                return
            }

            if hasError {
                print("‚ùå [WAYPOINT ROUTING] Failed to calculate all segments")
                self.status = .error("Failed to calculate route through waypoints")
                return
            }

            // Combine segments into complete route
            self.combineRouteSegments(allSegmentRoutes)
        }
    }

    private func combineRouteSegments(_ segmentRoutes: [[MKRoute]]) {
        print("üß≠ [WAYPOINT ROUTING] Combining \(segmentRoutes.count) route segments")

        guard !segmentRoutes.isEmpty, segmentRoutes.allSatisfy({ !$0.isEmpty }) else {
            print("‚ùå [WAYPOINT ROUTING] Missing route segments")
            status = .error("Could not complete route calculation")
            return
        }

        // Create up to 3 route combinations from segment alternates
        var combinedRoutes: [NavigationRoute] = []

        // Combination 1: Fastest route for each segment
        let fastestCombo = segmentRoutes.map { $0.first! }
        if let route1 = createCombinedRoute(from: fastestCombo, name: "Fastest Route") {
            combinedRoutes.append(route1)
        }

        // Combination 2: Use second route option for first segment if available
        if segmentRoutes[0].count > 1 {
            var combo2 = segmentRoutes.map { $0.first! }
            combo2[0] = segmentRoutes[0][1]
            if let route2 = createCombinedRoute(from: combo2, name: "Alternate Route 1") {
                combinedRoutes.append(route2)
            }
        }

        // Combination 3: Use second route for last segment if available and multi-segment
        if segmentRoutes.count > 1, segmentRoutes[segmentRoutes.count - 1].count > 1 {
            var combo3 = segmentRoutes.map { $0.first! }
            combo3[segmentRoutes.count - 1] = segmentRoutes[segmentRoutes.count - 1][1]
            if let route3 = createCombinedRoute(from: combo3, name: "Alternate Route 2") {
                combinedRoutes.append(route3)
            }
        }

        print("‚úÖ [WAYPOINT ROUTING] Created \(combinedRoutes.count) route options")

        availableRoutes = combinedRoutes
        status = .selectingRoute(combinedRoutes)
    }

    private func createCombinedRoute(from segments: [MKRoute], name: String) -> NavigationRoute? {
        guard !segments.isEmpty else { return nil }

        // Combine all polylines
        var allCoordinates: [CLLocationCoordinate2D] = []
        for route in segments {
            let points = route.polyline.points()
            for i in 0..<route.polyline.pointCount {
                allCoordinates.append(points[i].coordinate)
            }
        }

        // Create combined polyline
        let combinedPolyline = MKPolyline(coordinates: allCoordinates, count: allCoordinates.count)

        // Calculate total distance and time
        let totalDistance = segments.reduce(0.0) { $0 + $1.distance }
        let totalTime = segments.reduce(0.0) { $0 + $1.expectedTravelTime }

        print("‚úÖ [WAYPOINT ROUTING] \(name): \(totalDistance/1609.34) mi, \(totalTime/60) min")

        // Verify highway avoidance for combined route
        if settings.avoidHighways {
            var hasHighway = false
            for segment in segments {
                if checkForHighways(in: segment) {
                    hasHighway = true
                    break
                }
            }

            if hasHighway {
                print("‚ö†Ô∏è [HIGHWAY CHECK] Combined route '\(name)' contains highways despite avoidance preference")
            } else {
                print("‚úÖ [HIGHWAY CHECK] Combined route '\(name)' successfully avoids highways")
            }
        }

        return NavigationRoute(
            route: segments[0],
            name: name,
            distance: totalDistance,
            expectedTravelTime: totalTime,
            combinedPolyline: combinedPolyline,
            routeSegments: segments
        )
    }

    // MARK: - Start Navigation
    func startNavigation(with route: NavigationRoute) {
        print("üß≠ [NAV START] startNavigation called")
        selectedRoute = route

        // Store full route polyline for trimming as user progresses
        fullRoutePolyline = route.combinedPolyline ?? route.route.polyline
        remainingRoutePolyline = fullRoutePolyline // Start with full route

        // Handle waypoint routes specially - combine all segment steps
        if let segments = route.routeSegments, !segments.isEmpty {
            print("üß≠ [NAV START] Using \(segments.count) route segments for waypoint route")
            prepareStepsFromSegments(segments, totalDistance: route.distance, totalTime: route.expectedTravelTime)
        } else {
            print("üß≠ [NAV START] Using single route with \(route.route.steps.count) steps")
            prepareSteps(from: route.route)
        }

        print("üß≠ [NAV START] Prepared \(routeSteps.count) total steps")
        currentStepIndex = 0
        updateCurrentAndNextSteps()
        status = .navigating
        print("üß≠ [NAV START] Status set to: navigating")
        print("üß≠ [NAV START] Current step: \(currentStep?.instruction ?? "none")")

        // Announce start
        if voiceGuidanceEnabled {
            speak("Navigation started. \(route.distanceString) to destination.")
        }
    }

    // MARK: - Stop Navigation
    func stopNavigation() {
        print("üõë [NAV STOP] stopNavigation called")
        print("üõë [NAV STOP] Previous status: \(status)")
        status = .idle
        selectedRoute = nil
        routeSteps = []
        currentStepIndex = 0
        currentStep = nil
        nextStep = nil
        remainingDistance = 0
        remainingTime = 0
        distanceToNextStep = 0
        lastAnnouncedDistance = nil
        consecutiveOffRouteCount = 0
        fullRoutePolyline = nil
        remainingRoutePolyline = nil
        speechSynthesizer.stopSpeaking(at: .immediate)
        print("üõë [NAV STOP] Navigation stopped, status now: idle")
    }

    // MARK: - Private Methods
    private func setupLocationTracking() {
        locationManager.$userLocation
            .compactMap { $0 }
            .sink { [weak self] location in
                self?.updateNavigationProgress(with: location)
            }
            .store(in: &cancellables)
    }

    private func prepareSteps(from route: MKRoute) {
        routeSteps = route.steps.map { step in
            NavigationStep(
                instruction: step.instructions,
                distance: step.distance,
                polyline: step.polyline,
                notice: step.notice
            )
        }

        remainingDistance = route.distance
        remainingTime = route.expectedTravelTime
    }

    private func prepareStepsFromSegments(_ segments: [MKRoute], totalDistance: Double, totalTime: TimeInterval) {
        print("üß≠ [NAV START] Combining steps from \(segments.count) segments")

        // Combine all steps from all segments
        var allSteps: [NavigationStep] = []

        for (segmentIndex, segment) in segments.enumerated() {
            print("üß≠ [NAV START] Segment \(segmentIndex + 1) has \(segment.steps.count) steps")

            let segmentSteps = segment.steps.map { step in
                NavigationStep(
                    instruction: step.instructions,
                    distance: step.distance,
                    polyline: step.polyline,
                    notice: step.notice
                )
            }

            allSteps.append(contentsOf: segmentSteps)
        }

        routeSteps = allSteps
        remainingDistance = totalDistance
        remainingTime = totalTime

        print("üß≠ [NAV START] Total combined steps: \(allSteps.count)")
    }

    private func updateCurrentAndNextSteps() {
        guard currentStepIndex < routeSteps.count else {
            currentStep = nil
            nextStep = nil
            return
        }

        currentStep = routeSteps[currentStepIndex]

        if currentStepIndex + 1 < routeSteps.count {
            nextStep = routeSteps[currentStepIndex + 1]
        } else {
            nextStep = nil
        }
    }

    private func updateNavigationProgress(with location: CLLocation) {
        guard status == .navigating || status == .rerouting,
              let route = selectedRoute,
              currentStepIndex < routeSteps.count else {
            print("üîä [NAV PROGRESS] Not updating - status: \(status), stepIndex: \(currentStepIndex)/\(routeSteps.count)")
            return
        }

        let currentLocation = location.coordinate
        let currentStepCoordinate = getStepCoordinate(at: currentStepIndex)

        // Calculate distance to current step
        let stepLocation = CLLocation(latitude: currentStepCoordinate.latitude, longitude: currentStepCoordinate.longitude)
        distanceToNextStep = location.distance(from: stepLocation)

        print("üîä [NAV PROGRESS] Step \(currentStepIndex + 1)/\(routeSteps.count), distance to step: \(distanceToNextStep)m (\(distanceToNextStep * 3.28084)ft)")

        // Update remaining route polyline (trim traveled portion)
        trimRoutePolyline(userLocation: location)

        // Check if we should advance to next step (within 20 meters)
        if distanceToNextStep < 20 {
            advanceToNextStep()
        }

        // Update remaining distance and time
        updateRemainingStats(from: location)

        // Check if off route
        if isOffRoute(location: location) {
            consecutiveOffRouteCount += 1
            print("‚ö†Ô∏è [OFF ROUTE] Off route detected - count: \(consecutiveOffRouteCount)/5")
            if consecutiveOffRouteCount >= 5 { // 5 consecutive readings to avoid false positives
                print("üî¥ [OFF ROUTE] Triggering reroute after 5 consecutive readings")
                handleOffRoute()
            }
        } else {
            if consecutiveOffRouteCount > 0 {
                print("‚úÖ [ON ROUTE] Back on route - resetting counter")
            }
            consecutiveOffRouteCount = 0
        }

        // Voice guidance - use published property
        print("üîä [NAV PROGRESS] Voice check - enabled: \(voiceGuidanceEnabled), distance: \(distanceToNextStep)m")
        if voiceGuidanceEnabled {
            announceIfNeeded(distanceToStep: distanceToNextStep)
        } else {
            print("‚ö†Ô∏è [NAV PROGRESS] Voice guidance disabled - skipping announcement")
        }

        // Check if arrived
        if let dest = destination {
            let destLocation = CLLocation(latitude: dest.latitude, longitude: dest.longitude)
            if location.distance(from: destLocation) < 30 { // Within 30 meters
                arriveAtDestination()
            }
        }
    }

    private func getStepCoordinate(at index: Int) -> CLLocationCoordinate2D {
        guard index < routeSteps.count else {
            return destination ?? CLLocationCoordinate2D()
        }

        let step = routeSteps[index]
        let points = step.polyline.points()
        let count = step.polyline.pointCount

        if count > 0 {
            return points[count - 1].coordinate
        }

        return destination ?? CLLocationCoordinate2D()
    }

    private func advanceToNextStep() {
        currentStepIndex += 1
        updateCurrentAndNextSteps()
        lastAnnouncedDistance = nil // Reset for next step

        if let instruction = currentStep?.instruction, !instruction.isEmpty {
            if voiceGuidanceEnabled {
                speak(instruction)
            }
        }
    }

    private func updateRemainingStats(from location: CLLocation) {
        guard let route = selectedRoute else { return }

        // Calculate remaining distance (simple approximation)
        var distance: Double = 0
        for i in currentStepIndex..<routeSteps.count {
            distance += routeSteps[i].distance
        }
        distance += distanceToNextStep

        remainingDistance = distance

        // Estimate remaining time based on current speed
        if let speed = locationManager.userLocation?.speed, speed > 0 {
            remainingTime = distance / speed
        } else {
            // Fallback to original estimate
            let progress = 1.0 - (distance / route.distance)
            remainingTime = route.expectedTravelTime * (1.0 - progress)
        }
    }

    private func isOffRoute(location: CLLocation) -> Bool {
        guard currentStepIndex < routeSteps.count else { return false }

        let step = routeSteps[currentStepIndex]
        let polyline = step.polyline

        // Check distance to polyline
        let distance = distanceToPolyline(from: location.coordinate, polyline: polyline)
        let isOff = distance > offRouteThreshold

        if isOff {
            print("‚ö†Ô∏è [OFF ROUTE CHECK] Distance from route: \(distance)m (threshold: \(offRouteThreshold)m)")
        }

        return isOff
    }

    private func distanceToPolyline(from coordinate: CLLocationCoordinate2D, polyline: MKPolyline) -> CLLocationDistance {
        let points = polyline.points()
        let count = polyline.pointCount

        var minDistance = CLLocationDistance.greatestFiniteMagnitude

        let userLocation = CLLocation(latitude: coordinate.latitude, longitude: coordinate.longitude)

        for i in 0..<count {
            let point = points[i].coordinate
            let pointLocation = CLLocation(latitude: point.latitude, longitude: point.longitude)
            let distance = userLocation.distance(from: pointLocation)

            if distance < minDistance {
                minDistance = distance
            }
        }

        return minDistance
    }

    private func handleOffRoute() {
        print("üîÑ [REROUTE] User is off route - recalculating...")

        // Prevent rapid rerouting (wait 10 seconds between reroutes)
        if let lastReroute = lastRerouteTime, Date().timeIntervalSince(lastReroute) < 10 {
            print("‚è≥ [REROUTE] Skipping reroute - last reroute was less than 10 seconds ago")
            return
        }

        lastRerouteTime = Date()
        status = .rerouting
        consecutiveOffRouteCount = 0

        if let dest = destination {
            // Keep waypoints that haven't been passed yet
            filterPassedWaypoints()
            calculateRoutes(to: dest)
        }

        if voiceGuidanceEnabled {
            speak("Recalculating route")
        }
    }

    private func filterPassedWaypoints() {
        guard let userLoc = locationManager.userLocation else { return }

        // Remove waypoints that are behind the user
        let originalCount = waypoints.count
        waypoints = waypoints.filter { waypoint in
            let waypointLoc = CLLocation(latitude: waypoint.latitude, longitude: waypoint.longitude)
            // Keep waypoints that are more than 50 meters away (haven't been reached yet)
            return userLoc.distance(from: waypointLoc) > 50
        }

        if waypoints.count < originalCount {
            print("üìç [WAYPOINT] Filtered out \(originalCount - waypoints.count) passed waypoints")
        }
    }

    private func arriveAtDestination() {
        print("üéâ [ARRIVAL] Arrived at destination!")
        status = .arrived
        if voiceGuidanceEnabled {
            speak("You have arrived at your destination")
        }
    }

    // MARK: - Route Trimming (Progressive Polyline)
    private func trimRoutePolyline(userLocation: CLLocation) {
        guard let fullPolyline = fullRoutePolyline else { return }

        let points = fullPolyline.points()
        let count = fullPolyline.pointCount

        // Find closest point on route to user
        var closestIndex = 0
        var minDistance = CLLocationDistance.greatestFiniteMagnitude

        for i in 0..<count {
            let point = points[i].coordinate
            let pointLocation = CLLocation(latitude: point.latitude, longitude: point.longitude)
            let distance = userLocation.distance(from: pointLocation)

            if distance < minDistance {
                minDistance = distance
                closestIndex = i
            }
        }

        // Create new polyline from closest point to end
        if closestIndex < count - 1 {
            var remainingCoordinates: [CLLocationCoordinate2D] = []

            for i in closestIndex..<count {
                remainingCoordinates.append(points[i].coordinate)
            }

            remainingRoutePolyline = MKPolyline(coordinates: remainingCoordinates, count: remainingCoordinates.count)
        }
    }

    // MARK: - Voice Guidance
    private func announceIfNeeded(distanceToStep: Double) {
        // Find the next announcement threshold
        guard let nextDistance = announcementDistances.first(where: { $0 < distanceToStep }) else {
            return
        }

        // Check if we haven't announced this distance yet
        if let lastAnnounced = lastAnnouncedDistance, lastAnnounced <= nextDistance {
            return
        }

        // Announce
        print("üîä [VOICE GUIDANCE] Announcing at \(nextDistance)m (\(nextDistance * 3.28084)ft)")
        if let instruction = currentStep?.instruction {
            let distanceText = formatDistance(nextDistance)
            speak("In \(distanceText), \(instruction)")
            lastAnnouncedDistance = nextDistance
        }
    }

    private func formatDistance(_ meters: Double) -> String {
        let feet = meters * 3.28084

        if feet >= 5280 {
            let miles = feet / 5280
            return String(format: "%.1f miles", miles)
        } else if feet >= 1000 {
            let roundedFeet = (feet / 100).rounded() * 100
            return "\(Int(roundedFeet)) feet"
        } else {
            return "\(Int(feet)) feet"
        }
    }

    private func speak(_ text: String) {
        print("üîä [VOICE] Speaking: \(text)")
        speechSynthesizer.stopSpeaking(at: .immediate)

        let utterance = AVSpeechUtterance(string: text)
        utterance.voice = AVSpeechSynthesisVoice(language: "en-US")
        utterance.rate = 0.5 // Slightly slower for clarity
        utterance.volume = 1.0

        speechSynthesizer.speak(utterance)
    }
    
    // MARK: - Settings Management
    func updateSettings(_ newSettings: NavigationSettings) {
        settings = newSettings
        settings.save()
        
        // If currently navigating and settings changed, recalculate route
        if status == .navigating, let dest = destination {
            calculateRoutes(to: dest)
        }
    }
    
    func toggleVoiceGuidance() {
        voiceGuidanceEnabled.toggle()
        var settings = NavigationSettings.load()
        settings.voiceGuidanceEnabled = voiceGuidanceEnabled
        settings.save()
    }
}
